"""
**Jackknife** errors for (non-linear) functions of uncertain data, i.e. g(<a>,<b>,...)

Inspired by https://github.com/ararslan/Jackknife.jl.
"""
module Jackknife


"""
    leaveoneout(g::Function, samples::AbstractVector{<:Number}...)

Generates N sub-samples for each sample in `samples`, where one value is left
out and applies each sample mean to the function `g`. The result is used for
a 1-jackknife.

## Example:

Let `x` be a sample of length N (e.g. a time series of N random variables
generated by a Monte-Carlo algorithm) and `g` be some function acting on the
mean of that sample, e.g.
`g(first_moment, second_moment) = second_moment - first_moment^2`.
`leaveoneout(g, x, x.^2)` will generate N sub-samples `y_n` and `y_n.^2`, each
missing one (different) value from `x` and `x.^2` respectively. It will then
calculate `g(mean(y_n), mean(y_n.^2))` for each sub-sample and return the
result as a vector.
"""
function leaveoneout(g::Function, samples::AbstractVector{<:Number}...)
    @assert(
        length(samples[1]) > 1,
        "The sample must have multiple values! (length(samples[1]) > 1)"
    )

    full_sample_sums = map(sum, samples)
    invN1 = 1 / (length(samples[1]) - 1)
    red_sample_means = map(samples, full_sample_sums) do sample, full_sample_sum
        [(full_sample_sum - sample[i]) * invN1 for i in eachindex(sample)]
    end
    g.(red_sample_means...)
end


# old code below


using EllipsisNotation
import Statistics: mean, var

export jackknife_full, jackknife


"""
    jackknife_full(g::Function, x::AbstractArray) -> je, jstd

Jackknife estimate `je` and standard error `jstd` of `g(<a>,<b>,...)`.

Columns of `x` are time series of random variables, i.e. `x[i,1] = a_i`
and `x[i,2] = b_i`. For a given matrix input `x` the function `g`
must produce a scalar, for example `g(x) = @views mean(x[:,1])^2 - mean(x[:,2].^2)`.
"""
function jackknife_full(g::Function, x::AbstractArray{<:Number})
    gis = leaveoneout(g,x)
    return estimate(g,x,gis), bias(g,x,gis), std_error(g,x,gis)
end

jackknife_full(g::Function, xs...) = jackknife_full(g, hcat(xs...))




"""
    jackknife(g::Function, x::AbstractArray) -> jstd

Jackknife standard error `jstd` of `g(<a>,<b>,...)`.

Columns of `x` are time series of random variables, i.e. `x[i,1] = a_i`
and `x[i,2] = b_i`. For a given matrix input `x` the function `g`
must produce a scalar, for example `g(x) = @views mean(x[:,1])^2 - mean(x[:,2].^2)`.
"""
function jackknife(g::Function, x::AbstractArray{<:Number})
    gis = leaveoneout(g,x)
    return std_error(g,x,gis)
end

jackknife(g::Function, xs...) = jackknife(g, hcat(xs...))




"""
    leaveoneout(g::Function, x::AbstractArray)

Estimate `g(<a>,<b>,...)` systematically omitting each time index one
at a time. The result is a vector with the resulting jackknife block
values `g_i(x_[])`.

Columns of `x` are time series of random variables, i.e. `x[i,1] = a_i`
and `x[i,2] = b_i`. For a given matrix input `x` the function `g`
must produce a scalar, for example `g(x) = @views mean(x[:,1])^2 - mean(x[:,2].^2)`.
"""
function leaveoneout(g::Function, x::AbstractArray{<:Number})
    size(x,1) > 1 || throw(ArgumentError("The sample must have size > 1"))
    return @views [g(circshift(x, -i)[2:end,..]) for i in 0:size(x,1)-1]
end





"""
    var(g::Function, x::AbstractArray)

Compute the jackknife estimate of the variance of `g(<a>,<b>,...)`, where `g` is given as a
function that computes a point estimate (scalar) when passed a matrix `x`. Columns of `x`
are time series of the random variables.

For more details, see also [`leaveoneout](@ref).
"""
function var(g::Function, x::AbstractArray{<:Number}, gis::AbstractVector{<:Real})
    n = size(x,1)
    return var(gis) * (n - 1)^2 / n # Eq. (3.35) in QMC Methods book
end
var(g::Function, x::AbstractArray{<:Number}) = var(g,x,leaveoneout(g, x))
var(g::Function, x::AbstractArray{<:Number}, gis::AbstractVector{<:Complex}) = var(g,x,real(gis)) + var(g,x,imag(gis))





"""
    std_error(g::Function, x::AbstractArray)

Compute the jackknife estimate of the one sigma error of `g(<a>,<b>,...)`, where `g` is given as a
function that computes a point estimate (scalar) when passed a matrix `x`. Columns of `x`
are time series of the random variables.

For more details, see also [`leaveoneout](@ref).
"""
std_error(g::Function, x::AbstractArray{<:Number}, gis::AbstractVector{<:Real}) = sqrt(var(g,x, gis))
std_error(g::Function, x::AbstractArray{<:Number}, gis::AbstractVector{<:Complex}) = sqrt(std_error(g,x,real(gis))^2 + std_error(g,x,imag(gis))^2)
std_error(g::Function, x::AbstractArray{<:Number}) = std_error(g,x,leaveoneout(g,x))





"""
    bias(g::Function, x::AbstractArray)

Compute the jackknife estimate of the bias of `g(<a>,<b>,...)`, which computes a point
estimate when passed a matrix `x`. Columns of `x` are time series of the random variables.

For more details, see also [`leaveoneout](@ref).
"""
function bias(g::Function, x::AbstractArray{<:Number}, gis::AbstractVector{<:Number}=leaveoneout(g, x))
    return (size(x,1) - 1) * (mean(gis) - g(x)) # Basically Eq. (3.33)
end





"""
    estimate(g::Function, x)

Compute the bias-corrected jackknife estimate of `g(<a>,<b>,...)`, which computes a
point estimate when passed a matrix `x`. Columns of `x` are time series of the random variables.

For more details, see also [`leaveoneout](@ref).
"""
function estimate(g::Function, x::AbstractArray{<:Number}, gis::AbstractVector{<:Number}=leaveoneout(g, x))
    n = size(x,1)
    return n * g(x) - (n - 1) * mean(gis) # Eq. (3.34) in QMC Methods book
end




end # module


# TODO: Prebinning + Jackknife
